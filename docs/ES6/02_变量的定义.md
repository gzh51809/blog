# 2 变量的定义

## let

关键字|简述
---|---
var|并不存在块级作用域的概念，如`if(1){var a = 1}`，在外部扔可访问。此外，还有`for循环`亦是如此。
let|在`{}`内构建块级作用域，且不存在变量提升。

> let的其他特性：

- 暂时性死区

	ES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。—— （TDZ）。暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

- 不允许重复声明

	`let`不允许在相同作用域内，重复声明同一个变量。

- 应该避免在块级作用域内声明函数

	如果确实需要，也应该写成函数表达式，而不是函数声明语句。
	
```js
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错：

```js
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```

## const

- `const`声明一个只读的常量。一旦声明，常量的值就不能改变;
- 和`let`一样，只在声明所在的块级作用域内有效;
- 本质：保证指向的那个内存地址不得改动。

对象：
```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

数组：
```js
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

!> 简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址, 因此等同于常量。
!> 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。


如果真的想将对象冻结，应该使用`Object.freeze`方法。

```js
const foo = Object.freeze({});
```

## ES6声明变量的六种方法

ES5: var、function
ES6: var、function、let、const、import、class


```js
function A() {
  
}

function B() {
  
}

let _p;
_p.prototype = new B();
_p.constructor = A;
A.prototype = _p;
```

## 顶层对象的属性

- ES5之中，顶层对象的属性与全局变量是等价的。—— JavaScript的败笔之一
- ES6之后，`let`、`const`、`class`声明的全局变量，不属于顶层对象的属性。

例子：
```js
var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
```


## Global对象

- 浏览器环境：window
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self
- Node环境：global

!> 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。

- 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。
- 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。
- 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法:

```js
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);
```

```js
// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

现在有一个提案，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。

垫片库system.global模拟了这个提案，可以在所有环境拿到global。

