# 9 对象的拓展

## 属性的简洁表示法

ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。

```js
var foo = 'bar';
var baz = {foo};
baz // {foo: "bar"}
```

CommonJS模块输出变量，就非常合适使用简洁写法。

## 属性名表达式
```js
// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;
```
上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。

但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。
```js
var obj = {
  foo: true,
  abc: 123
};
```
ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。

```js
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};
```

## 方法的 name 属性 


## Object.is() 


- == 会自动转换数据类型
- === NaN不等于自身，以及+0等于-0

Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
```js
Object.is('foo', 'foo')
// true
Object.is({}, {})
// false
```

## Object.assign()

Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。

注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

!> Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

!> Object.assign方法实行的是浅拷贝，而不是深拷贝。

有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。

应用：

- 给对象添加属性：

```js
class Point {
	constructor(x, y) {
		Object.assign(this, {x, y})
	}
	get z() {
		return Math.hypot(this.x, this.y)
	}
}

var ins = new Point(3,4)
console.log(ins)
console.log(ins.z)
```

- 给对象添加方法：

```js
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    // ···
  },
  anotherMethod() {
    // ···
  }
});
```
这种方法的好处在于并没有像 SomeClass.prototype = {} 一样覆盖了整个 proptotype。

- 克隆对象

```js
function clone(origin) {
  return Object.assign({}, origin)
}
```

不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码:

```js
function cloneWithProto(origin) {
	let _originProto = Object.getPrototypeOf(origin);
	return Object.assign(Object.create(_originProto), origin);
}
```

---
复习时间:

Object.getPrototypeOf() 的用法：

```js
let source = {a: 1}

let sourceProto = Object.getPrototypeOf(source);

console.log(source.__proto__ === sourceProto) // true
```

Object.create(proto) 的用法：

使用指定的原型对象和其属性创建了一个新的对象。

---

-  合并多个对象

```js
function merge(target, ...sources) {
	return Object.assign(target, ...sources)
}
```


## 属性的可枚举性

Object.getOwnPropertyDescriptor(obj, property

- for...in循环：只遍历对象自身的和继承的可枚举的属性
- Object.keys()：返回对象自身的所有可枚举的属性的键名
- JSON.stringify()：只串行化对象自身的可枚举的属性

另外，ES6规定，所有Class的原型的方法都是不可枚举的。
所以，尽量不要用for...in循环，而用Object.keys()代替。

## 属性的遍历


方法|继承|可枚举|不可枚举|Symbol
---|---
for...in|√    |√      |×|
Object.keys(obj)|×|√  |×
Object.getOwnPropertyNames(obj)|√    |√      |√ |×
Object.getOwnPropertySymbols(obj)|×    |×      |× |√
Reflect.ownKeys(obj)|√    |√      |√ |√


## __proto__

无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。

- Object.setPrototypeOf()
- Object.getPrototypeOf()
- Object.create()


## Object.keys()等

- Object.keys() - [] （不含继承的）所有可遍历（enumerable）属性的键名。
- Object.values() - [] (不含继承的）所有可遍历（enumerable）属性的键值。
- Object.entries() - [] 成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。

```js
let peopleA = {
  name: 'chen',
  age: 22
}

console.log(Object.entries(peopleA))
// [['name', 'chen'], ['age', 22]]
```

## 对象的扩展运算符

### 对象的解构赋值

```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

### 扩展运算符

扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

```js
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
```

这等同于使用Object.assign方法。

## Object.getOwnPropertyDescriptors() 

ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。

ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。


## Null 传导运算符

比如，要读取message.body.user.firstName，安全的写法是写成下面这样。
```js
const firstName = (message
  && message.body
  && message.body.user
  && message.body.user.firstName) || 'default';
```
这样的层层判断非常麻烦，因此现在有一个提案，引入了`Null 传导运算符`（null propagation operator）`?.`，简化上面的写法。

const firstName = message?.body?.user?.firstName || 'default';
