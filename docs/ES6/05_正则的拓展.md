# 5 正则的拓展

## RegExp构造函数

ES5定义一个RegExp有两种形式：

- 第一个参数为字符串，第二个为正则修饰符（i、g、m）
```js
var regex = new RegExp('xyz', 'i');
// 等价于
var regex = /xyz/i;
```

- 参数就是一个正则表达式，不能有第二个修饰符

```js
var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
```

!> ES6的改变是: 即使第一个参数为一个正则表达式，也可以不能有第二个修饰符，第二个修饰符会覆盖第一个正则表单时中的修饰符


```js
new RegExp(/abc/ig, 'i').flags // i
```

## 字符串的正则方法

字符串对象共有4个方法，可以使用正则表达式:

- match()
- replace()
- search()
- split()

## u修饰符 

ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于`\uFFFF`的`Unicode`字符。也就是说，会正确处理四个字节的UTF-16编码。

## y修饰符

!> y修饰符的作用与g修饰符类似。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

一个例子，自行理解：

```js
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

- lastIndex，下一次匹配开始的位置。
- y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。

## sticky属性

表示是否设置了`y`修饰符

## flags属性

返回正则表达式的修饰符。

## RegExp.escape() 
字符串必须转义，才能作为正则模式。

本应在ES7中出现，但还是流产了。polyfill:

```js
// $& 表示对应的匹配
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
```
也可以用：

[regexp.escape](https://github.com/ljharb/regexp.escape)

## s 修饰符

点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。

以下四个字符属于`行终止符`。

- U+000A 换行符（\n）
- U+000D 回车符（\r）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）

引入/s修饰符，使得.可以匹配任意单个字符:

```js
/foo.bar/s.test('foo\nbar') // true
```
