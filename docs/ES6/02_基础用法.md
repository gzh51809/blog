# 基本特性

## let

关键字|简述
---|---
var|并不存在块级作用域的概念，如`if(1){var a = 1}`，在外部扔可访问。此外，还有`for循环`亦是如此。
let|在`{}`内构建块级作用域，且不存在变量提升。

> let的其他特性：

- 暂时性死区

	ES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。—— （TDZ）。暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

- 不允许重复声明

	`let`不允许在相同作用域内，重复声明同一个变量。

- 应该避免在块级作用域内声明函数

	如果确实需要，也应该写成函数表达式，而不是函数声明语句。
	
```js
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错：

```js
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```

## const

- `const`声明一个只读的常量。一旦声明，常量的值就不能改变;
- 和`let`一样，只在声明所在的块级作用域内有效;
- 本质：保证指向的那个内存地址不得改动。

对象：
```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

数组：
```js
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

!> 简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址, 因此等同于常量。
!> 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。


如果真的想将对象冻结，应该使用`Object.freeze`方法。

```js
const foo = Object.freeze({});
```

## 严格模式时还会报错