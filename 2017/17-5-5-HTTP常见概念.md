# HTTP

## 老生常谈的话题：浏览器敲下一段url后按回车, 通常会经历什么？（HTTP请求的生命周期）

> 简单点说，可以分为三个主要步骤:
	
1. `HTTP`客户端发起请求，创建端口
2. `HTTP`服务器在短期监听客户端请求
3. `HTTP`服务器想客户端返回状态和内容
	
> 形象点说，可以论述如下(以打开/刷新`baidu`为例:)：

1. `Chrome`搜索自身的`DNS`缓存（`Chromw`过期时间为`60s`,`IE`是`30min`，`Firefox`也是`60s`，`safari`约为`10s`）；
2. 浏览器没有找到或者缓存已经失效，就回去搜索操作系统自身的DNS缓存；（`Windows`缓存失效时间默认为`86400s`，也就是一天。）;
3. 读取本地的`HOSTS`文件;
4. 如果本地`HOSTS`文件也没有找到，浏览器会发起一个`DNS`的系统调用;
		
    - 宽带运营服务器查看本地缓存;
    - 运营商服务器发起一个迭代DNS解析的请求;
    - 找到之后运营商服务器把结果返回给操作系统并缓存下来，操作系统内核再把结果返回给浏览器;
    - 最终浏览器拿到了`www.baidu.com`对应的`ip`地址;
		
4. 浏览器获得域名对应的`ip`地址后，浏览器会以一个随机端口向服务器的`web`程序发起请求（`TCP`连接请求），经过层层路由、网卡、TCP协议栈、防火墙过滤，最终到达`web`服务端, 然后开始经典的三次握手；
	
    - 客户端首先向服务器说，兄弟，咱们聊聊天，听得到我说话吗？
    - 服务器说，听得到，咱来唠唠
    - 客户端再说，好的，咱们开始唠唠了    
		
6. `TCP/IP`连接建立起来以后，浏览器就能向服务器端发送`HTTP`请求了
		
7. 服务器端接受到请求，净多后端的一些处理之后，把处理后的结果返回给浏览器。把`www.baidu.com`的整个页面返回
	
8. 浏览器拿到`HTML`代码，开始解析，其中，里面的`js`、`css`、`img`等静态资源也都是一个个`HTTP`请求，都要经过上述的主要的七个步骤。
	
9. 开始对页面进行渲染。最终把一个完整的页面返回给用户。


## 如果一个域名的DNS解析结果会有多个的话，浏览器是如何处理的呢？

Chrome浏览器会优先向第一个IP发起HTTP请求，如果不通，再向后面的IP发起HTTP请求。

## 什么是HTTP协议？

HTTP 是基于 `TCP/IP` 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用`80`端口。

## HTTP 常用的Header有哪些？

属性|描述
---|---
Content-Type: text/html | 标识资源的类型编码（`MIME type`）
Content-Encoding: gzip | 标识资源的压缩方法
Connection: keep-alive | ，可以解决`HTTP/1.0`每个TCP连接只能发一个请求的缺陷，使用 `keep-alive` 可以实现一个可复用的TCP连接，但是这非标准。
Connection: close | 由于`HTTP/1.1`默认引入了持久连接，因此好的做法是在客户端最后一个请求，发送 `Connection: close` 关闭TCP连接
Content-Length : 1994 | 声明数据长度（单位是字节）

## `HTTP/1.1`有哪些特性？

1. 持久连接；
2. 管道机制；
3. Content-Length 字段
4. 分块传输编码（采用"流模式"（stream）取代"缓存模式"（buffer））：`Transfer-Encoding: chunked`


---


# HTTP手记

## TCP/IP 网络分层


- 应用层：HTTP，FTP，SMTP，DNS
- 传输层：TCP，UDP
- 网络层：IP
- 数据链路层
- 物理层

1. TCP UDP的区别？

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道


## HTTP状态码

- 100: 消息

这一类型的状态码，代表请求已被接受，需要继续处理。

100 Continue。跨域的时候 OPTION 会返回


- 200：成功

这一类型的状态码，代表请求已成功被服务器接收、理解、并接受

200 OK
204 No Content


- 3xx: 重定向

301 永久重定向
202 临时重定向

304 内容没有被修改


- 4xx: 请求错误

400：错误的请求

1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。

401 未验证 Unauthorized

不知道用户是谁

403 未授权 禁止访问 Forbidden

服务器理解请求，但拒绝执行（知道你是谁，但是你没有这权限！）

404 Not found

- 5xx


500 Internal Server Error
501 Not Implemented
503 Service Unavailable



## 缓存


web缓存分为很多种，比如数据库缓存、代理服务器缓存、还有我们熟悉的CDN缓存，以及浏览器缓存。


## Cache-Control：

- max-age（单位为s）：指定设置缓存最大的有效时间，定义的是时间长短。
- s-maxage（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。

max-age用于普通缓存，而s-maxage用于代理缓存。

- public：多用户间共享
- private：私有的缓存
- no-cache：指定不缓存响应，表明资源不进行缓存
- no-store 绝对禁止缓存


## Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。


## Last-modified

服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。


## ETag

使用ETag可以解决Last-modified存在的一些问题：

    a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 

    b、如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 

    c、一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。



## HTTP/2.0 相比1.0有哪些重大改进？

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。

加了一个二进制分帧层

首部压缩

服务端推送


1. HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

节约带宽


HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求 body 发送到服务器。

这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。


HTTP1.0是没有host域的，HTTP1.1才支持这个参数。


多路复用

HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

