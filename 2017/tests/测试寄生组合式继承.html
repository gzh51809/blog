<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
</head>
<body>

<script>
	//			console.log(childPrototype.__proto__)
	//			console.log(Reflect.getOwnPropertyDescriptor(childPrototype, '__proto__'))
	//			console.log(Reflect.getOwnPropertyDescriptor(childPrototype, 'login'))
	//					childPrototype.__proto__ = {
	//											configurable: true,
	//											enumerable: false,
	//											value: fancyMerge(parentPrototype, childPrototype),
	//											writable: true
	//										}

	//			childPrototype.__proto__ =
	//			Object.defineProperty(
	//					childPrototype,
	//					'__proto__',
	//					{
	//						configurable: true,
	//						enumerable: false,
	//						value: fancyMerge(parentPrototype, childPrototype),
	//						writable: true
	//					}
	//			)
		// 不同于object.assign, 该merge方法会复制所有的源键
		// 不管键名是 Symbol 或字符串，也不管是否可枚举。
		function fancyMerge(target, source) {
			for (const key of Reflect.ownKeys(source)) {
				Reflect.defineProperty(target, key, Reflect.getOwnPropertyDescriptor(source, key))
			}
			return target
		}

		// 终极版寄生组合式继承
		function inherit(child, parent) {
			const objectPrototype = Object.prototype
			// 继承父类的原型
			const parentPrototype = Object.create(parent.prototype)
			let childPrototype = child.prototype
			// 若子类没有继承任何类，直接合并子类原型和父类原型上的所有方法
			// 包含可枚举/不可枚举的方法
			if (Reflect.getPrototypeOf(childPrototype) === objectPrototype) {
				child.prototype = fancyMerge(parentPrototype, childPrototype)
			} else {
				while (Reflect.getPrototypeOf(childPrototype) !== objectPrototype) {
					childPrototype = Reflect.getPrototypeOf(childPrototype)
				}
				Reflect.setPrototypeOf(childPrototype, parent.prototype)

			}
			// 重写被污染的子类的constructor
			parentPrototype.constructor = child
		}

		// GithubUser
		function GithubUser(username, password) {
			let _password = password
			this.username = username
		}

		GithubUser.prototype.login = function () {
			console.log(this.username + '要登录Github，密码是' + _password)
		}

		// JuejinUser
		function JuejinUser(username, password) {
			GithubUser.call(this, username, password)
			WeiboUser.call(this, username, password)
			this.articles = 3
		}

		JuejinUser.prototype.readArticle = function () {
			console.log('Read article')
		}

		// WeiboUser
		function WeiboUser(username, password) {
			this.key = username + password
		}

		WeiboUser.prototype.compose = function () {
			console.log('compose')
		}

		inherit(JuejinUser, GithubUser) // 先让 JuejinUser 继承 GithubUser

		inherit(JuejinUser, WeiboUser)  // 再让 JuejinUser 继承 WeiboUser

		const juejinUser1 = new JuejinUser('ulivz', 'xxx')

		console.log(juejinUser1)

		console.log(juejinUser1 instanceof GithubUser) // true
		console.log(juejinUser1 instanceof WeiboUser) // true

</script>

</body>
</html>