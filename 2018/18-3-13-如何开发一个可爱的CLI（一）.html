<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../../../../Applications/WebStorm.app/Contents/bin/multimarkdown_layout-fx.css">
<style>
.container { width: 100%; }
.wiki-container { width: 100%; }
.wiki-body { width: 100%; }
</style>
<link rel="stylesheet" href="../../../../../../Applications/WebStorm.app/Contents/bin/multimarkdown_darcula-fx.css">
<link rel="stylesheet" href="../../../../../../Applications/WebStorm.app/Contents/bin/multimarkdown_hljs-darcula.css">
<title>18-3-13-&#22914;&#20309;&#24320;&#21457;&#19968;&#20010;&#21487;&#29233;&#30340;CLI&#65288;&#19968;&#65289;.md</title>
<script src="../../../../../../Applications/WebStorm.app/Contents/bin/multimarkdown_highlight.pack.js"></script>
</head>
<body>
<div class="container">
<div id="readme" class="boxed-group">
<h3>
   <a href="#" name="markdown-page" id="markdown-page" class="page-anchor"><span class="bookicon octicon-book"></span>
</a>  18-3-13-如何开发一个可爱的CLI（一）.md
</h3>
<article class="markdown-body">
<h1 id="前言"><a href="#前言" name="前言" class="anchor"><span class="octicon octicon-link"></span></a>前言</h1>
<p>相信大家都写过<code>vue</code>,<code>react</code>或者<code>angular</code>的各位同学，也一定不会对以下库陌生：</p>
<ul>
  <li><a href="https://github.com/vuejs/vue-cli"><strong>vue-cli</strong></a></li>
  <li><a href="https://github.com/facebook/create-react-app"><strong>create-react-app</strong></a></li>
  <li><a href="https://github.com/angular/angular-cli"><strong>angular-cli</strong></a></li>
</ul>
<p>体验过上述工具的同学，有没有发现他们都有一个共同点——提供了一个可供快速开发的样板文件（<strong>boilerplate</strong>）。本文就将从样板文件入来进行阐述。通过本文，你将学到：</p>
<ol>
  <li>一个<code>CLI</code>工具需要解决的问题；</li>
  <li>写一个<code>CLI</code>的基本思路；</li>
  <li>写一个<code>CLI</code>需要做哪些准备；</li>
</ol>
<blockquote>
  <p>PS：由于脚手架的英文 scaffolding 太长，本文我将以更可爱的 cli 来代替。</p>
</blockquote>
<h1 id="预热"><a href="#预热" name="预热" class="anchor"><span class="octicon octicon-link"></span></a>预热</h1>
<p>由于篇幅有限，本节将以<code>create-react-app</code>和<code>vue-cli</code>为例（真地很难说服大家我是<code>ng</code>起家的...），回顾其使用过程：</p>
<p>首先是<code>create-react-app</code>， 按照README，我们生成出一个基本项目后，打开目录，其目录结构如下：</p>
<pre><code class="nohighlight">my-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public 
│   └── favicon.ico
│   └── index.html
│   └── manifest.json 
└── src
    └── App.css
    └── App.js
    └── App.test.js
    └── index.css
    └── index.js
    └── logo.svg
    └── registerServiceWorker.js
</code></pre>
<p>说一下其中两个有意思的点：</p>
<ul>
  <li><code>public/manifest.json</code>: 这是PWA 的一部分，用来描述应用相关的信息。以前开发<code>cordova</code>的时候，这个还用来做过热更新。</li>
  <li><code>src/registerServiceWorker.js</code>: 安装Service Workers文件。</li>
</ul>
<blockquote>
  <p>很久没用它，原来已经默认支持<code>PWA</code>了，nice, 还不会的同学赶紧学起来，这里就不展开了。</p>
</blockquote>
<p>接着，我们打开<code>package.json</code>，探一下究竟：</p>
<pre><code class="json">{
  &quot;name&quot;: &quot;my-app&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^16.2.0&quot;,
    &quot;react-dom&quot;: &quot;^16.2.0&quot;,
    &quot;react-scripts&quot;: &quot;1.1.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<p>非常简洁，但是有一个<code>react-scripts</code>。看起来很陌生，但是如果我告诉你它的依赖中有<code>babel</code>、<code>webpack</code>、<code>webpack-dev-server</code>和<code>autoprefixer</code>这些常见的前端流氓，我想你也清楚了<code>react-scripts</code>到底做了什么：</p>
<blockquote>
  <p>包装了 <code>webpack</code> 和 <code>webpack-dev-server</code>，提供一套默认的配置（内置css，file，svg等等各种loader），在 <code>react-scripts start</code> 和 <code>react-scripts build</code> 时直接运行这些配置。</p>
</blockquote>
<p>一句话概括，就是为了帮你简化构建时的配置（Create React apps with no build configuration.😂）。</p>
<p>当然，零配置并非适用于大型定制项目的开发，<code>react-scripts</code>就像一个巨大的黑盒一样，总有存在一些其未提供 API 或者指令的场景，让你无从下手。<code>react-scripts</code>当然也不傻，还提供了一个比较fancy的指令：</p>
<ul>
  <li><code>react-scripts eject</code>: 将所有的工具（配置文件和 package.json 依赖库）解压到应用所在的路径。</li>
</ul>
<p>厉害了😅，来运行看看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621b170cb9e018d?w=1938&amp;h=928&amp;f=png&amp;s=198823" alt="" /></p>
<p>当所有的依赖暴露出来是，果然<code>package.json</code>瞬间爆炸性增长了，顺时有点怀念从前的美好了。</p>
<p>好了，说到这里，create-react-app 要解决的问题就是：</p>
<ol>
  <li>根据样板文件生成统一的项目骨架，让开发者快速投入开发；</li>
  <li>预置了一个易于开发的<code>react-scripts</code>，让开发者省略痛苦的配置流程.（<code>webpack</code>配置工程师看来要失业了😇）</li>
</ol>
<p>接下来，再回顾一下 <code>vue-cli</code>。截止本文书写日期， <a href="mailto:vue-cli@3.0">vue-cli@3.0</a> 仍然处于 beta 阶段，因此本文将以 2.x.x 为例，我们创建一个名为 my-vue-app，模板为 webpack-simple 的 vue 项目：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621f8676c796ccd?w=1032&amp;h=576&amp;f=gif&amp;s=65117" alt="" /></p>
<p>可见，vue-cli在生成项目之前多了一个非常重要的一步 —— Prompt，也就是问询，根据询问的内容最终生成你的项目。两条FYI：</p>
<ol>
  <li>vue-cli 的问询功能是使用 <a href="https://github.com/SBoudrias/Inquirer.js">Inquirer.js</a> 这个库完成的。</li>
  <li>webpack-simple 源码你可以在这里找到 <a href="https://github.com/vuejs-templates/webpack-simple">webpack-simple</a> 。</li>
</ol>
<p>对本节做一下结，一个脚手架通常由以下基本几部分组成：</p>
<ol>
  <li>问询（Prompts）</li>
  <li>样板文件（Boilerplate）</li>
  <li>生成文件（Generate）</li>
</ol>
<h1 id="实战"><a href="#实战" name="实战" class="anchor"><span class="octicon octicon-link"></span></a>实战</h1>
<p>经过上一节的洗礼，你可能已经有大致的思路了，然后，让我们以 vue-cli 为例，直接进入实战吧。</p>
<h2 id="基本思路"><a href="#基本思路" name="基本思路" class="anchor"><span class="octicon octicon-link"></span></a>基本思路</h2>
<ol>
  <li>定义一个模板包的规则，这里采用 vue-cli 的规则：template 为源文件，meta.js/meta.json 为配置入口文件。</li>
</ol>
<pre><code class="json">my-first-package
├── meta.js
└── template
</code></pre>
<ol start="2">
  <li>解析包的meta.js，获得要询问的问题（prompts），并运行它，将最终用户的答案分配到一个上下文对象中；</li>
  <li>读取 template 中的内容，用刚刚获取的上下文对象去渲染它。</li>
</ol>
<h2 id="伪代码实现"><a href="#伪代码实现" name="伪代码实现" class="anchor"><span class="octicon octicon-link"></span></a>伪代码实现</h2>
<p>以下是一个CLI的伪代码实现：</p>
<pre><code class="js">// 10行伪代码实现一个CLI
function CLI(packageSourcePath) {
    const context = {}
    const meta = require(path.join(packageSourcePath, 'meta.js'))
    const templatePath = path.join(packageSourcePath, 'template')
    const { prompts } = meta
    return promptsRunner(prompts).then(anwsers =&gt; {
        Object.assign(context, anwsers)
        return generateFiles(templatePath, context)
    })
    .then(() =&gt;  console.log('[OK]'))
    .error(() =&gt; console.log('[Error]'))
}
</code></pre>
<p>其中，promptsRunner用来问询，generateFiles 用来渲染并生成文件。哇！原来这么简单。</p>
<h2 id="技术选型"><a href="#技术选型" name="技术选型" class="anchor"><span class="octicon octicon-link"></span></a>技术选型</h2>
<p>这是 vue-cli 的技术选型：</p>
<ol>
  <li>问询：<a href="https://github.com/SBoudrias/Inquirer.js">Inquirer.js</a></li>
  <li>命令行解析：<a href="https://github.com/tj/commander.js">commander.js</a></li>
  <li>模板渲染：<a href="https://github.com/wycats/handlebars.js">handlebars.js</a></li>
  <li>文件生成：<a href="https://github.com/segmentio/metalsmith">metalsmith</a></li>
</ol>
<p>热衷于看这个世界的你，是否已经跃跃欲试了呢?</p>
<h2 id="更多"><a href="#更多" name="更多" class="anchor"><span class="octicon octicon-link"></span></a>更多</h2>
<p>当然，如果只是这样的一个 CLI，很显然只是玩具，你可以考虑支持以下可爱的特性：</p>
<ol>
  <li>在Context中注入默认的一些属性（如git的username）</li>
  <li>支持文件过滤（根据Context过滤）</li>
  <li>支持文件重命名（vue-cli默认不直接支持，但可以通过 metalsmith 的插件实现）</li>
  <li>支持包管理（如包的生成，缓存，拉取，更新，删除，自动化测试）</li>
  <li>提供一些生命周期的钩子（如beforePrompt，beforeRender，beforeExit等等）</li>
  <li>动态的输出路径（这个对于我来说很有用）</li>
</ol>
<p>当然，还有很多了，只要你想得到。</p>
<h1 id="甜点时刻"><a href="#甜点时刻" name="甜点时刻" class="anchor"><span class="octicon octicon-link"></span></a>甜点时刻</h1>
<p>是时候给大家介绍一些甜点了。</p>
<h2 id="sao"><a href="#sao" name="sao" class="anchor"><span class="octicon octicon-link"></span></a>SAO</h2>
<blockquote>
  <p>Github传送门：<a href="https://github.com/saojs/sao">https://github.com/saojs/sao</a></p>
</blockquote>
<p>一个听起来很骚气的名字，这是我们可爱的 EGOIST 写的一个库，基本上实现了上述我说的所有特性。</p>
<p>最为关键的是，SAO目前已经提供了大量的高质量的样板文件：</p>
<table>
  <thead>
    <tr><th>name</th><th>description</th></tr>
  </thead>
  <tbody>
    <tr><td><a href="https://github.com/egoist/template-template">template</a></td><td>Template for scaffolding out an SAO template</td></tr>
    <tr><td><a href="https://github.com/lassjs/lass">lass</a></td><td>Lass scaffolds a modern package boilerplate for node</td></tr>
    <tr><td><a href="https://github.com/ladjs/lad">lad</a></td><td>Lad scaffolds a Koa webapp and API framework for node</td></tr>
    <tr><td><a href="https://github.com/egoist/template-vue">vue</a></td><td>Kickstart a Vue project with <a href="https://github.com/egoist/poi">Poi</a></td></tr>
    <tr><td><a href="https://github.com/egoist/template-gi">gi</a></td><td>Generate .gitignore file in your project</td></tr>
    <tr><td><a href="https://github.com/egoist/template-nm">nm</a></td><td>Scaffold out a node module</td></tr>
    <tr><td><a href="https://github.com/egoist/template-vue-webpack">vue-webpack</a></td><td>Vue.js offcial webpack template (SAO port)</td></tr>
    <tr><td><a href="https://github.com/egoist/template-basic">basic</a></td><td>Basic project skeleton</td></tr>
    <tr><td><a href="https://github.com/zcong1993/template-react">react</a></td><td>SAO template for react with vbuild</td></tr>
    <tr><td><a href="https://github.com/tiaanduplessis/template-micro-service">micro-service</a></td><td>Scaffolding out a micro-service</td></tr>
    <tr><td><a href="https://github.com/therealklanni/template-node-cli">node-cli</a></td><td>Scaffold a node cli tool</td></tr>
    <tr><td><a href="https://github.com/egoist/template-next">next</a></td><td>Scaffold out a Next.js project</td></tr>
    <tr><td><a href="https://github.com/egoist/template-electron">electron</a></td><td>Scaffold out an Electron project</td></tr>
    <tr><td><a href="https://github.com/tiaanduplessis/template-expo">expo</a></td><td>Scaffold out an Expo app</td></tr>
  </tbody>
</table>
<p>太强大了，这也大概就是我不得不爱 <a href="https://github.com/egoist/">EGOIST</a> 的原因了吧。</p>
<h2 id="poz"><a href="#poz" name="poz" class="anchor"><span class="octicon octicon-link"></span></a>poz</h2>
<blockquote>
  <p>Github传送门：<a href="https://github.com/ulivz/poz">https://github.com/ulivz/poz</a></p>
</blockquote>
<p>由于在实际生产中需要支持 重命名 和 动态输出路径，我写了 POZ  这个库，在前人的基础上，基于完全不一样的实现，实现了一样的功能，并加了一点儿特效，这大概就是造轮子的乐趣吧。欢迎大家 Fxxk/Issue。</p>
<p>最近 POZ 也计划开始开发 1.0的稳定版本了，快来看看这个 <a href="https://github.com/ulivz/poz/wiki/POZv1-Roadmap">RoadMap</a>，太有野心了有木有。</p>
<h2 id="alphax"><a href="#alphax" name="alphax" class="anchor"><span class="octicon octicon-link"></span></a>alphax</h2>
<blockquote>
  <p>Github传送门：<a href="https://github.com/ulivz/alphax">https://github.com/ulivz/alphax</a></p>
</blockquote>
<p>这是 poz 底层使用的一个库，基于Stream，灵感来源于 metalsmith 和 SAO 底层的 majo，最近我彻底重写了该库，让其有了以下可爱的特性：</p>
<ol>
  <li>极简的API；</li>
  <li>任务流控制；</li>
  <li>中间件；</li>
  <li>基于纯函数或JSON的的文件过滤；</li>
  <li>基于纯函数或JSON的文件重命名；</li>
  <li>支持不写入硬盘，易于测试;</li>
</ol>
<p>它使用起来像这样：</p>
<pre><code class="js">alphax()
  .src('**')
  .task(task1)
  .task(task2)
  .task(task3)
  .use(file =&gt; file.content += Date.now())
  .rename(filepath =&gt; filepath.replace('{name}', name))
  .rename(filepath =&gt; filepath.replace('{age}', age))
  .transform(content =&gt; content.replace('{name}', name))
  .filter(filepath =&gt; filepath.endWith('.js'))
  .filter(filepath =&gt; !filepath.startWith('test'))
  .dest('dist')
  .then(files =&gt; console.log(files))
  .catch(error =&gt; console.log(error))
</code></pre>
<p>如果你不喜欢函数，也可以用配置的方式来：</p>
<pre><code class="js">const config = {
  tasks: [task1, task3, task3],
  use: file =&gt; file.content += Date.now(),
  rename: {
    '{name}': name,
    '{age}': age
  },
  filter: {
    'app.js': true,
    'test.js': false
  },
  transform(content) {
    return content.replace('{name}', name)
  }
}

alphax()
  .src('**', config)
  .dest('dist')
  .then(files =&gt; console.log(files))
  .catch(error =&gt; console.log(error))
</code></pre>
<p>相信这个lib已经解决掉你大部分的 meta.js 的API设计问题了😄。附上用可爱的 <a href="https://github.com/egoist/docute">docute</a> 写的文档地址： <a href="http://www.v2js.com/alphax/#/">Documentation</a></p>
<h1 id="总结"><a href="#总结" name="总结" class="anchor"><span class="octicon octicon-link"></span></a>总结</h1>
<p>一个CLI归根到底是要解决的是生产力和统一性的问题，但是，对于create-react-app这种过度封装，和 <a href="mailto:vue-cli@2.x.x">vue-cli@2.x.x</a> 的过度松散，似乎都不是最佳方案。配置少和拓展性高这本来就是两个互相矛盾的话题，从长远来看，选择怎样的CLI还是依赖于具体的场景，但作为一个CLI开发者，如果做到更好的平衡，还值得多多思考。</p>
<p>本文仅谈及了写一个CLI工具的第一部分，其基本思路较为简单，只是实现层面会有较多的优化点和 error catch 😅，Good luck！</p>
<p>下文，我将继续阐述类似于 create-react-app 中 react-scripts 的基本实现原理及其思路，实际上，这也是 <a href="mailto:vue-cli@3.x.x">vue-cli@3.x.x</a> 和 poi 所具有的功能，敬请关注。</p>
<p>以上，全文终。）</p>
</article>
</div>
</div>
<script>hljs.initHighlightingOnLoad();</script></body>
</html>
